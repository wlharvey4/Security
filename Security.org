# -*- mode:org; fill-column:79; -*-
#+title:Security Information
#+author:Pinecone062
#+date:April 14, 2019
#+macro:version 0.2.14.<2019-05-01 Wed 23:00>
Version {{{version}}} By {{{author}}}

* JSON Web Tokens
** Article---How JWTs Secure Your API
:PROPERTIES:
:source-url:   https://vuejsdevelopers.com/2019/04/15/api-security-jwt-json-web-tokens/?
:source-title: How JSON Web Token (JWT) Secures Your API
:source-author: Anthony Gore
:source-date: April 14, 2019
:END:
*** Introduction From How JWTs Securre Your API
You've probably heard that the JSON Web Token (JWT) is the current
state-of-the-art technology for securing APIs.  Like most security topics, it's
important to understand how it works (at least, somewhat) if you're planning to
use it.  The problem is that most explanations of JWT are technical and
headache-inducing.  Let's see if I can explain how a JWT can secure your API
without crossing your eyes!

*** API Authentication

{{{heading(Need to Authenticate Access)}}}

#+CINDEX:authentication
Certain API resources need restricted access.  We don't want one user to be
able to change the password of another user, for example.  That's why we
protect certain resources---make users supply their ID and password before
allowing access---in other words, we authenticate them.

{{{heading(HTTP Requests are Stateless)}}}

#+CINDEX:stateless, HTTP
The difficulty in securing an HTTP API is that requests are stateless---the API
has no way of knowing whether any two requests were from the same user or not.
So why don't we require users to provide their ID and password on every call to
the API?  Only because that would be a terrible user experience.

*** JSON Web Token
:PROPERTIES:
:article-title: What is a JSON Web Token?
:article-cite: https://robmclarty.com/blog/what-is-a-json-web-token
:article-author: Rob McLarty
:END:
What we need is a way to allow a user to supply their credentials just once,
but then be identified in another way by the server in subsequent requests.
Several systems have been designed for doing this, and the current
state-of-the-art standard is the JSON Web Token.

{{{heading(How JWTs Work)}}}

There's a great [[https://robmclarty.com/blog/what-is-a-json-web-token][article]] on the topic which makes a good analogy about how JSON
web tokens work:
#+begin_quote
Instead of an API, imagine you're checking into a hotel.  The "token" is the
plastic hotel security card that you get that allows you to access your room,
and the hotel facilities, but not anyone else's room.  When you check out of
the hotel, you give the card back.  This is analogous to logging out.
#+end_quote

*** Structure of the Token

{{{heading(What a JWT Looks Like)}}}

#+CINDEX:HTTP request header
#+CINDEX:header, HTTP request
#+CINDEX:request, HTTP header
#+CINDEX:bearer, authorization
#+CINDEX:authorization, bearer
#+CINDEX:token
#+CINDEX:bearer token
Normally a JSON web token is sent via the header of HTTP requests. Here's what
one looks like:
: Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dozjgNryP4J3jVmNHl0w5N_XgL0n3I9PlFUP0THsR8U
In fact, the token is the part after "Authorization: Bearer", which is just the
HTTP header info.

{{{heading(The Header Payload and Signature)}}}

#+CINDEX:header
#+CINDEX:payload
#+CINDEX:signature
#+CINDEX:Base 64 encode
Before you conclude that it's incomprehensible gibberish, there are a few
things you can easily notice.  Firstly, the token consists of three different
strings, separated by a period.  These three string are base 64
encoded[fn::Base 64 encoding is a way of transforming strings to ensure they
don't get screwed up during transport across the web.  It is not a kind of
encryption and anyone can easily decode it to see the original data.] and
correspond to:
- the /header/,
- the /payload/, and
- the /signature/.


We can decode these strings to get a better understand of the structure of JWT.

{{{subheading(Header)}}}

#+CINDEX:header, dfn
The following is the decoded header from the token.  The @@texinfo:@dfn{header}@@ is
meta information about the token.  It doesn't tell us much to help build our
basic understanding, so we won't get into any detail about it.

#+BEGIN_SRC js
{
  "alg": "HS256",
  "typ": "JWT"
}
#+END_SRC

{{{subheading(Payload)}}}

#+CINDEX:payload, dfn
The payload is of much more interest.  The @@texinfo:@dfn{payload}@@ can include any
data you like, but you might just include a user ID if the purpose of your
token is API access authentication.

#+BEGIN_SRC js
{
  "userId": "1234567890"
}
#+END_SRC

It's important to note that the payload is not secure.  Anyone can decode the
token and see exactly what's in the payload.  For that reason, we usually
include an ID rather than sensitive identifying information like the user's
email.  Even though this payload is all that's needed to identify a user on an
API, it doesn't provide a means of authentication.  Someone could easily find
your user ID and forge a token if that's all that was included.

So this brings us to the signature, which is the key piece for authenticating
the token.

*** Hashing Algorithms
#+CINDEX:hashing algorithm, dfn
#+CINDEX:hashing algorithm, SHA256
#+CINDEX:hash, dfn
#+CINDEX:SHA256 hashing algorithm
Before we explain how the signature works, we need to define what a
@@texinfo:@dfn{hashing algorithm}@@ is.  To begin with, it's a function for
transforming a string into a new string called a @@texinfo:@dfn{hash}@@.  For example,
say we wanted to hash the string "Hello, world".  Here's the output we'd get
using the =SHA256= hashing algorithm:
: 4ae7c3b6ac0beff671efa8cf57386151c06e58ca53a78d83f36107316cec125f
The most important property of the hash is that you can't use the hashing
algorithm to identify the original string by looking at the hash.  In other
words, we can't take the above hash and directly figure out that the original
string was "Hello, world". The hash is complicated enough that guessing the
original string would be infeasible.  There are many different types of hashing
algorithms, but =SHA256= is commonly used with JWT.

{{{heading(JWT Signature)}}}

#+CINDEX:signature, dfn
So coming back to the JWT structure, let's now look at the third piece of the
token, the @@texinfo:@dfn{signature}@@.  This actually needs to be calculated:

#+BEGIN_SRC js
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  "secret string"
);
#+END_SRC

Here's an explanation of what's going on here:

#+CINDEX:hashing function
- Firstly, =HMACSHA256= is the name of a hashing function and takes two
  arguments:
  - the string to hash, and
  - the "secret" (defined below).
- Secondly, the string we hash is the base 64 encoded /header/, plus the base 64
  encoded /payload/.
- Thirdly, the /secret/ is an arbitrary piece of data that only the server
  knows.


Why include the header and payload in the signature hash?  This ensures the
signature is unique to this particular token.

{{{subheading(The Secret)}}}

#+CINDEX:secret
What's the @@texinfo:@dfn{secret}@@?  To answer this, let's think about how you would
forge a token.  We said before that you can't determine a hash's input from
looking at the output.  However, since we know that the signature includes the
header and payload, as those are public information, if you know the hashing
algorithm (hint: it's usually specified in the header), you could generate the
same hash.  But the secret, which only the server knows, is not public
information.  Including it in the hash prevents someone generating their own
hash to forge the token.  And since the hash obscures the information used to
create it, no one can figure out the secret from the hash, either.

{{{subheading(Salting)}}}

#+CINDEX:salting
The process of adding private data to a hash is called @@texinfo:@dfn{salting}@@ and
makes cracking the token almost impossible.

*** Authentication Process
#+CINDEX:authentication process
So now you have a good idea of how a token is created.  How do you use it to
authenticate your API?

{{{heading(Login)}}}

#+CINDEX:token, generate
#+CINDEX:generate token
A token is generated when a user logs in and is stored in the database with the
user model.  The token then gets attached as the /authorization header/ in the
response to the login request.

#+caption:Generating a Token Upon Login; ~loginController.js~
#+name:generate-token
#+BEGIN_SRC js
if (passwordCorrect) {
  user.token = generateToken(user.id);
  user.save();
  res.headers("authorization", `Bearer ${token}`).send();
}
#+END_SRC

{{{heading(Authenticating requests)}}}

#+CINDEX:requests, authenticate
#+CINDEX:authenticate requests
Now that the client has the token, it can attach it to any future requests to
authenticate the identity of the user.  When the server receives a request with
an authorization token attached, the following happens:

1. It decodes the token and extracts the ID from the payload.
2. It looks up the user in the database with this ID.
3. It compares the request token with the one that's stored with the user's
   model.  If they match, the user is authenticated.

#+caption:The Server authenticates requests from the Client; ~authMiddleware.js~
#+name:authenticate-requests
#+BEGIN_SRC js
const token = req.header.token;
const payload = decodeToken(token);
const user = User.findById(payload.id);
if (user.token = token) {
  // Authorized
} else {
  // Unauthorized
}
#+END_SRC

{{{heading(Logging out)}}}

#+CINDEX:logout
If the user logs out, simply delete the token attached to the user model, and
now the token will no longer work.  A user will need to log in again to generate
a new token.

#+caption:Logging a user out; ~logoutController.js~
#+name:logout
#+BEGIN_SRC js
user.token = null;
user.save();
#+END_SRC

*** Wrapup
So that's a very basic explanation of how you can secure an API using JSON Web
Tokens.  I hope your head doesn't hurt too much.

** Course---JSON Web Token Authentication with Node.js
:PROPERTIES:
:source:   Egghead.io
:author:   Joel Lord
:END:
*** About the Course
In this course, we will build a simple authentication server that will act as a
token issuer, and we will use those tokens to access resources on an API.
Starting from scratch, the participants will learn how easy token based
authentication can be and will understand how to use them on their APIs as well
as on the front end of their web applications.
**** Source Code
[[https://github.com/eggheadio-projects/egghead-auth-course/tree/master][eggheadio-projects/egghead-auth-course]]
**** The Author
- Joel Lord
- [[http://www.javascripteverything.com/about][About the author]]
- [[http://www.javascripteverything.com/about][Javascript Everything]] author's blog
- [[https://github.com/joellord][GitHub]]
**** Author's Introduction
00:00 Hey everyone, welcome to this course on JSON web token authentication
with Node.JS.  The goal of this course is to introduce you to web-based
authentication using JWTs.

00:11 Through these few lessons, we will build a simple application that will
connect to a secured API and we will build an authentication server to provide
us with tokens that we need in order to connect and access those routes.

00:25 We will start slowly by building a simple web server using Express.  We
will then see how to make this API more flexible by introducing environment
variables, and then how to handle post request, and how to parse the body of
those requests.

00:40 At this point, we will be able to start building our authentication
server.  The server will validate the user credentials and provide those users
with a JSON web token.  Using this token, we will be able to go back to our API
and secure one of our routes so that only an authenticated user can access
those resources.

00:59 Finally, what would a back-end be without a good UI? We will build a
quick front-end that will connect to our API.  This UI will also collect user
credentials and send them over to the authentication server to fetch a JWT.

01:13 All this will be done using plain old vanilla JavaScript and none of
those fancy frameworks.  This will give you all the necessary tools to
implement this solution in any application you might build.

01:25 Of course, the examples in this course will be simple, and we will focus
more on the concepts rather than building a real secure API.  For that reason,
we will also show you how to switch your primitive authentication server to use
a proven solution.

01:40 In this lesson, you will be introduced to Auth0 as a solution to provide
secure identity management and federated log in to your users.  Go ahead, watch
this course, and learn how to build more secure applications right now.
*** Lesson 0---Package Setup
The course will be set up in a root directory ~egghead-jwt-auth~, with
~lesson#~ directories for each lesson 1 through 8.  The following shell script
checks for the existence of a ~package.json~ file in the root directory; if one
is found, it simply prints a message.  If one is not found, then it initializes
a new package using the ~yarn init~ command using default values.  The lessons
will add and install prerequisites to this ~package.json~ file.

#+NAME:tangle-files
#+BEGIN_SRC emacs-lisp :results silent :exports results
(org-babel-tangle-file (buffer-file-name))
#+END_SRC

#+name:package-init
#+begin_src sh :dir egghead-jwt-auth :results output :exports both
[ -e package.json ] && \
  echo "package.json has already been created" || \
  yarn --yes init
  cat package.json
#+end_src

*** Lesson 1---Set Up a Web Server in Node.js Using Express
#+CINDEX:Express web server
#+CINDEX:web server, Express
#+CINDEX:server, Express web
#+CINDEX:404 error
In this lesson, we build a very simple Express server.  This server will have a
single route that displays the current date and time and a handler for =404=
pages.

**** Setting Up A Little Express Server
#+CINDEX:Express server, build
00:00 To build your first Express server, the first thing you need to do is to
~require express~.  In order for your code to be able to use it, you need to
install it using ~yarn add express~:

#+name:lesson1-package.json
#+begin_src sh :dir egghead-jwt-auth :results output :exports results
yarn add express
#+end_src

: package.json
: ------------

#+begin_src sh :dir egghead-jwt-auth :results output :exports results
cat package.json
#+end_src

: index.js
: --------

#+name:require-express
#+begin_src js -n
const express = require("express");
#+end_src

{{{heading(Setup Constants)}}}

#+CINDEX:PORT, define
00:16 We'll go back to our code.  We'll declare a new constant ~app~ which will
use the ~express~ library that we've just included.  We'll also declare a new
constant for the =PORT= number.  We'll use =8888= for now.

#+name:app-express
#+begin_src js +n
const app = express();
#+end_src

#+name:port-8888
#+begin_src js +n
const PORT = 8888;
#+end_src

{{{heading(Setup Routes)}}}

{{{subheading(Status Route)}}}

#+CINDEX:route, define
#+CINDEX:@code{app.get}
#+CINDEX:status route
00:30 Then we can do our first route.  We'll use ~app.get~, and we'll specify
the name of the route.  In this case, we're using =status=, and it takes a
callback which has a request and a response as parameters.

#+name:status-route
#+begin_src js +n
app.get("/status", (req, res) => {
    const localTime = (new Date()).toLocaleTimeString();
    res.status(200).send(`Server time is ${localTime}.`);
});
#+end_src
{{{subheading(Catchall Route)}}}

#+CINDEX:catchall route
01:13 Let's also add a catchall route. We'll just use star (=*=), which means
any route that wasn't defined already.  01:19 It also takes a callback with a
request and response.  We can build our response here, and it will simply sense
that as =404=, or 'page not found'.

#+name:catchall-route
#+begin_src js +n
app.get("*", (req, res) => {
    res.sendStatus(404);
});
#+end_src

{{{heading(Start the App Listening)}}}

#+CINDEX:@code{app.listen}
#+CINDEX:app, run
01:30 Finally, we'll use ~app.listen~ to initialize our server.  It'll take a
=PORT=---which we've defined earlier---as a parameter, and a callback for on
success.  01:42 We'll simply say "Server is running on port", and we'll specify
the =PORT= number here.  You now have your first express server.

#+name:app-listen
#+begin_src js +n
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}.`);
});
#+end_src

**** Testing the Server

This Makefile sets up some commands to run specific lessons.  Each lesson's
server can be started by moving into the root directory (~egghead-jwt-auth/~)
and typing:
: make lesson# where =#= is one of 1..8.

Thereafter, specific commands can be run from a different terminal, such as:
: make open-browser-status

#+BEGIN_SRC sh :mkdirp yes :tangle egghead-jwt-auth/Makefile
FORCE:

.phony : lesson1
lesson1 : FORCE
	node lesson1

#+END_SRC

01:53 If we go back to our terminal, we can start the server by using Node from
the root directory:
: make lesson1

We've got our server running.

These three Makefile rules provide easy commands to open different routes in
your default browser:

#+BEGIN_SRC sh :tangle egghead-jwt-auth/Makefile
.phony: open-browser
open-browser :
	open http://localhost:8888/

.phony: open-browser-status
open-browser-status :
	open http://localhost:8888/status/

.phony: open-browser-random
open-browser-random :
	open http://localhost:8888/random/

#+END_SRC

#+CINDEX:page not found error
02:02 Now if we go through our browser window, we can type in the
~localhost:8888~.  We'll get a 'page not found' because that route was not
defined.
: make open-browser

#+CINDEX:status route
02:10 We can use =/status= to get the server time, and any other page will give
us a =404= error.
: make open-browser-status
: make open-browser-random

That's it.  You've got your first Express server up and running.
**** Express Server Index.js Code
#+caption:Lesson 1 ~index.js~
#+name:lesson01-index.js
#+begin_src js -n :tangle egghead-jwt-auth/lesson1/index.js :mkdirp yes :noweb yes
<<require-express>>
<<app-express>>
<<port-8888>>

<<status-route>>
<<catchall-route>>

<<app-listen>>
#+end_src

*** Lesson 2---Set the Server Port in Express Using an Environment Variable
#+CINDEX:environment variables
In this lesson we learn how to use an environment variable to set the port of
an express server.

**** Use ~process.env~ to Set the =PORT= Variable
#+CINDEX:@code{process.env}
#+CINDEX:@code{PORT} environment variable, set
00:00 We'll change the =PORT= that this server is using.  We'll use
~process.env~ to access the environment variables from our ~index.js~, and then
we'll create a new variable called =PORT=.  If the =PORT= environment variable
is not defined, we'll still use =8888= as a default.

: index.js
: ----------
#+name:port-env-or-assign
#+begin_src js -n
const PORT = process.env.PORT || 8888;
#+end_src

**** Testing the =PORT= Assignment
00:15 If you run this server, we see that the server is running on =port 8888=.
If we do an ~export~ in our terminal and we set the =PORT= environement
variable for our operating system to say =3000=
: export PORT=3000
{{{noindent}}}and we run this server again, we can see that the server is now
running on ~port 3000~.

00:34 If we open our browser, we go to =localhost:8888=, it can't be
reached.  If we go to =3000=, we're getting a =404= in this case.  If we go to
=localhost:3000/status=, we are getting the server time.

00:48 That's how you set the =PORT= inside an environment variable.

**** Lesson 2 ~index.js~ Code
#+caption:Lesson 2 ~index.js~
#+name:lesson2-index.js
#+begin_src js -n :tangle egghead-jwt-auth/lesson2/index.js :mkdirp yes :noweb yes
<<require-express>>
<<app-express>>
<<port-env-or-assign>>

<<status-route>>
<<catchall-route>>

<<app-listen>>
#+end_src

{{{heading(Adding a Makefile Rule for Lesson 2)}}}

From within the root directory (~egghead-jwt-auth/~) run the command:
: make lesson2
to start the server.  Then type:
: open-browser-3000
: open-browser-status-3000
: open-browser-random-3000
to test.

#+begin_src sh :tangle egghead-jwt-auth/Makefile
.phony : lesson2
lesson2 : FORCE
	(export PORT=3000; node lesson2)
.phony : open-browser-3000
open-browser-3000 :
	open http://localhost:3000/
.phony : open-browser-status-3000
open-browser-status-3000 :
	open http://localhost:3000/status/
.phony : open-browser-random-3000
open-browser-random-3000 :
	open http://localhost:3000/random/
#+end_src

*** Lesson 3---Add a =POST= Route To Express And Parse the Body
#+CINDEX:POST requests
#+CINDEX:@code{body-parser}
In this lesson, we see how to handle =POST= requests on our server and we
extract the data that was passed in the body of the requests using
~body-parser~.

**** Add a =POST= Method to ~index.js~
#+CINDEX:POST method
#+CINDEX:user login
#+CINDEX:login route
00:01 In order to handle our first post request, we will use Express' =POST=
method.  We will create a route that handles user logins.

#+CINDEX:request
#+CINDEX:response
00:08 The first argument is a route, which is =/login= in our case.  The second
argument is a callback with the =request= and =response= arguments.

#+CINDEX:username property
#+CINDEX:JSON object
#+CINDEX:post login route
00:15 Let's now define a constant that will contain the name of the user that
was posted to this route.  The constant name =user= will have the value of the
=username= property that was passed in our =request= as a JSON object.

#+name:post-route
#+begin_src js -n
app.post("/login", (req, res) => {
    const user = req.body.username;

#+end_src

**** Add ~body-parser~ Middleware
#+CINDEX:middleware, body-parser
#+CINDEX:body-parser middleware
00:27 At this point, Express can't read the body of the request.  We will need
to ~require~ an additional middleware called ~body-parser~.

#+name:require-body-parser
#+begin_src js -n
const bodyParser = require("body-parser");
#+end_src

We also go into the terminal to install this new library.

#+name:install-body-parser
#+begin_src sh :dir egghead-jwt-auth :results output :exports both
yarn add body-parser
#+end_src

: package.json
: ------------
#+begin_src sh :dir egghead-jwt-auth :results output :exports results
cat package.json
#+end_src

#+CINDEX:use method, express
#+CINDEX:JSON responses
00:40 Now that it's installed, we can add the middleware to Express using the
=use= method.  We will specify that it will handle JSON responses.

#+name:app-use-body-parser
#+begin_src js -n
app.use(bodyParser.json());
#+end_src

**** Build the =response=
#+CINDEX:response, post request
#+CINDEX:200 status
#+CINDEX:status 200
#+CINDEX:success status 200
00:49 We are now able to read the =request= body, so our constant contains the
=username= that was passed into login route.  We are ready to build our
=response=, which has a status of =200= because this is a success.

01:01 We will send back a simple string that says, "You logged in with
username: ${user}".  It will display the =username= that we just received.

#+name:post-route-res
#+begin_src js -n
    res
    .status(200)
    .send(`You logged in with username: "${user}"`);
});
#+end_src

**** Start the Server
01:08 Let's start our server using ~node~.  From the root directory type:
: make lesson3

#+name:Makefile
#+begin_src sh :tangle egghead-jwt-auth/Makefile
.phony : lesson3
lesson3 : FORCE
	(export PORT=3000;node lesson3)
#+end_src

The server is now listening on =localhost:3000=, which was defined as an
environment variable previously.

**** Test the Server
#+CINDEX:Postman
#+CINDEX:@command{curl}
01:18 To test this new route, we can use Postman (or ~curl~).  If we try to do
a =GET= request to =/status=, we should get the local time:
: make open-browser-status-3000

#+CINDEX:POST request
#+CINDEX:@code{username} property
#+CINDEX:Content-Type
#+CINDEX:application/json
01:28 Now, we can do a =POST= request to the =/login= route.  Let's start by
specifying the body of our request.  It will be a JSON object with a =username=
property.  Make sure that you change the Content-Type to =application/json=.

#+name:Makefile
#+begin_src sh :tangle egghead-jwt-auth/Makefile
.phony : post-login
post-login : FORCE
	curl \
	  --header Content-Type:application/json \
	  --data   '{"username":"admin"}' \
	  http://localhost:3000/login \
#+end_src

#+CINDEX:parse POST request
01:43 If we run this, you get a, "You logged in with username: \"admin\""
message.  That is how you parse a =POST= request and handle the =request= data.

**** Lesson 3 ~index.js~ Code
#+caption:Lesson 3 ~index.js~
#+name:lesson3-index.js
#+begin_src js :tangle egghead-jwt-auth/lesson3/index.js :mkdirp yes :noweb yes
<<require-express>>
<<require-body-parser>>

<<app-express>>
<<app-use-body-parser>>

<<status-route>>
<<post-route>>
<<post-route-res>>
<<catchall-route>>

<<port-env-or-assign>>
<<app-listen>>
#+end_src

*** Lesson 4---Provide Users With A JSON Web Token
#+CINDEX:token issuer
#+CINDEX:JSON web token
In this lesson, we will build a token issuer that will return a JSON Web
Token.  This simple server will have a single endpoint for login that queries a
list of users and returns a web token for the matching user.

**** The User Database
#+CINDEX:authentication server
#+CINDEX:user database
#+CINDEX:user array
00:00 Since this lesson is all about creating an authentication server, let's
start by creating a user database.  We will use a user array that contains all
of our users and store the passwords in plain text right now.

#+CINDEX:warning
00:11 Warning, do not do this in production.  You should always encrypt
passwords and ensure that no sensitive information about your users is
accessible to potential hackers.  For the sake of this lesson, let's just do it
this way.

#+name:users-array
#+begin_src js -n
const users = [
    {id: 1, username: "admin", password: "admin"},
    {id: 2, username: "guest", password: "guest"}
];
#+end_src

**** Authentication Route
#+CINDEX:@code{/login} route
#+CINDEX:@code{POST} request
#+CINDEX:user authentication
00:26 We can now start with our =/login= =POST= request.  This is the request
that will handle user authentication.  The first thing to check is if the
request is formatted correctly.  We are expecting both a username and a
password.

#+CINDEX:400 status
#+CINDEX:status 400
#+CINDEX:invalid request, status 400
00:45 If we don't have both, we =return= a status code of =400= for invalid
request, and we =send= a message to the user, saying that "You need a username
and password".  We can then do a ~return~ to stop the execution of this
callback.

#+CINDEX:@code{find} method
01:08 Now, if we have a valid request, we need to check if the user is in our
database.  Using the =find= method, we will check if we have a user that has a
=username= and =password= that matches those in the =request=.

#+CINDEX:401 status
#+CINDEX:status 401
#+CINDEX:unauthorized request
01:20 If we find a matching user, it will be stored in a constant, ~user~.  If
we can't find a matching user, we can send a response with the status of =401=
for =unauthorized=.  We can also ~send~ a message to the user, saying "User not
found".  Once again, we ~return~ to stop the execution of this callback.

#+name:authentication-login
#+begin_src js -n
app.post("/login", (req, res) => {
    if (!req.body.username || !req.body.password) {
        res
        .status(400)
        .send("You need a username and password");
        return;
    }

    const user = users.find((u) => {
        return u.username === req.body.username && u.password === req.body.password;
    });

    if (!user) {
        res
        .status(401)
        .send("User not found");
        return;
    }

#+end_src

**** Create a JWT for a Valid User
#+CINDEX:JSON web token
01:45 If we have a valid user, we will send back a JSON web token as a
response.

#+CINDEX:@code{jsonwebtoken} library
In order to do so, we will need to ~require~ the ~jsonwebtoken~ library.  We will
also need to install it using ~yarn add jsonwebtoken~.

#+name:require-jsonwebtoken
#+begin_src js -n
const jwt = require("jsonwebtoken");
#+end_src

#+begin_src sh :dir egghead-jwt-auth :results output :exports both
yarn add jsonwebtoken
#+end_src

: package.json
: ------------
#+begin_src sh :results output :exports both :dir egghead-jwt-auth
cat package.json
#+end_src

#+CINDEX:@code{sign} method
#+CINDEX:sign token
#+CINDEX:payload
#+CINDEX:secret key
02:13 Now that it's installed, we can use the =sign= method to create a sign
token.  We start by passing the payload we want to attach in the =jwt=.  We
then pass a string which is the =secret key=.  In this case, it's
"mysupersecretkey".

#+CINDEX:options
#+CINDEX:access_token
02:34 Finally, we can pass some options like in how much time this token will
expire, so we'll say expires in three hours for us.  Finally, we can send back
our response with a status of =200= and a JSON object with our =access_token=.

#+name:create-access-token
#+begin_src js -n
      const token = jwt.sign(
        {
          sub: user.id,
          username: user.username
        }, "mysupersecretkey", {expiresIn: "3 hours"}
      );

      res
       .status(200)
       .send({access_token: token});
  });
#+end_src

**** Testing the Lesson 4 Server
#+CINDEX:authentication server, run
03:01 We can now run the authentication server using node and the name of the
file.

#+begin_src sh :tangle egghead-jwt-auth/Makefile
.phony : lesson4
lesson4 : FORCE
	(export PORT=3000;node lesson4)
#+end_src

Let's now open Postman (use ~curl~) to test this out.

03:10 If we try a =GET= request on the server, we're getting a =404= because we
haven't defined any =GET= route on the server.

#+begin_src sh :dir egghead-jwt-auth
make open-browser-status-3000
#+end_src

Let's change that to a =POST= and use the =/login= endpoint that we just
created.  Sending a ~request~ to that URL without a body will give us a =400= with a
message, "You need a username and password."  Let's try to add those.

#+begin_src sh :tangle egghead-jwt-auth/Makefile
.phony : wrong-auth-login
wrong-auth-login :
	curl \
	  --header Content-Type:application/json \
	  --data   '{"username":"Felix","password":"the-cat"}' \
	  http://localhost:3000/login \

.phony : auth-login
auth-login :
	curl \
	  --header Content-Type:application/json \
	  --data   '{"username":"admin","password":"admin"}' \
	  http://localhost:3000/login \

#+end_src

03:29 For the =body=, select =raw= and make sure that the =type= is set to
=application/json=.  You can now type in a =username= and =password= in JSON
format.  If we type a wrong password, we should be getting the "User not found"
message.  If we fix the password to use the right one, we get our JSON object
with an =access_token=.

03:56 You can copy and paste this JSON web token in a website like ~jwt.io~ and
you will be able to see the content.  If you try it with another user like
=guest=, you will get a different =access_token=, and if we go into ~jwt.io~,
we can once again see all of the content and we can see that it's different
this time.

04:28 That's it.  You have now created your first authentication server.

**** Lesson 4 ~index.js~ Code
#+caption:Lesson 4 ~index.js~ Code
#+name:lesson4-index.js
#+begin_src js :tangle egghead-jwt-auth/lesson4/index.js :mkdirp yes :noweb yes
<<require-express>>
<<require-body-parser>>
<<require-jsonwebtoken>>

<<app-express>>
<<app-use-body-parser>>
<<users-array>>

<<status-route>>
<<authentication-login>>
<<create-access-token>>
<<catchall-route>>

<<port-env-or-assign>>
<<app-listen>>
#+end_src

*** Lesson 5---Allow CORS in Node.js and Expres
In this quick lesson, we see how to add the CORS middleware so that our Express
server can handle requests from different origins.

**** The CORS Prohibition
#+CINDEX:CORS prohibition
00:00 If you have an API that runs on a different server or even a different
port than your application, and you try to do a ~fetch~, you should see a
message in your console complaining about
=Access-Control-Allow-Origin=.[fn::Safari allows such a fetch, but Google
Chrome does not.]

[[file:./resources/cors-error-50.png]]

**** The Fix to the CORS Prohibition
00:19 The fix for this in your Express server is very simple.

#+CINDEX:@code{cors} library
First of all, you need to require the CORS library:

#+name:require-cors
#+begin_src js -n
const cors = require("cors");
#+end_src

Secondly, you need to tell your Express server to use this middleware by using
~app.use~ and the library that we've just installed.

#+name:app-use-cors
#+begin_src js +n
app.use(cors());
#+end_src

#+CINDEX:@code{express-jwt} library
Thirdly, use a different JSON web token library, ~express-jwt~, which the author
does not explain here, but explains in the next lesson.

#+name:require-expressjwt
#+begin_src js +n
const expressjwt = require("express-jwt");
#+end_src

#+name:jwtCheck
#+begin_src js +n
const jwtCheck = expressjwt({secret: "mysupersecretkey"});
#+end_src

<<add-express-jwt>>You'll also need to install both using ~yarn add~:

#+begin_src sh :dir egghead-jwt-auth :results output :exports both
yarn add cors express-jwt
#+end_src

Our ~package.json~ now looks like this:

: package.json
: ------------
#+begin_src sh :dir egghead-jwt-auth :results output :exports results
cat package.json
#+end_src

**** Start Lesson 5 Server Running
00:46 Now, if you restart your server and try the same ~fetch~ call in your
browser, you won't have that CORS error any more.

Start the server for this lesson with:
: make lesson5

#+begin_src sh :tangle egghead-jwt-auth/Makefile
.phony : lesson5
lesson5 : FORCE
	(export PORT=3000;node lesson5;)
#+end_src

[[file:./resources/cors-fix-50.png]]

**** Set Up Two New Routes for Public and Private Resources
Two new routes will be added here, and explained in the next lesson.

#+name:public-resource-route
#+begin_src js -n
app.get("/resource", (req, res) => {
    res
    .status(200)
    .send("Public resource; okay to see");
});

#+end_src

#+name:private-resource-route
#+begin_src js +n
app.get("/resource/secret", jwtCheck, (req, res) => {
    res
    .status(200)
    .send("Secret resource; you should be logged in to see this.");
});

#+end_src

**** Lesson 5 ~index.js~ Code
Here is the code for Lesson 5 in ~index.js~.  The two routes will be explained
in the next lesson.

#+name:Lesson5-index.js
#+begin_src js :tangle egghead-jwt-auth/lesson5/index.js :mkdirp yes :noweb yes
<<require-express>>
<<require-body-parser>>
<<require-cors>>
<<require-expressjwt>>
<<jwtCheck>>

<<app-express>>
<<app-use-body-parser>>
<<app-use-cors>>

<<public-resource-route>>
<<private-resource-route>>
<<catchall-route>>

<<port-env-or-assign>>
<<app-listen>>
#+end_src

*** Lesson 6---Authenticate Users With JWT for Access to Protected Resources
In this lesson, we build a simple API with two endpoints, one public and one
secure.  Using JWT and validating with the signature, we ensure that the user is
authorized and has access to a protected resource before serving it.

**** Create Two Resource Routes
00:00 In this lesson, we will create an API with two routes.  The first one for
the ~/resource~ endpoint will be public, and simply return a status of =200=, and
a message saying, "Public resource, you can see this".

#+begin_src js -n :noweb yes
<<public-resource-route>>
#+end_src

00:22 Our second route will be for the ~/resource/secret~ endpoint.  This will
be a secured route.  For this endpoint, we will return a =200=, as well as a
message that says, "Secret resource, you should be logged in to see this."

#+begin_src js +n :noweb yes
<<private-resource-route>>
#+end_src

**** Create an =API_PORT= Environment Variable
00:42 This server will run on the port specified by the environment variable
=API_PORT=.  Let's go into our terminal, set this using ~export~, and set the
=API_PORT= to =5000=.  Now, we can run the server by using ~node~ and the name
of the file.
: make lesson6

#+name:api-port
#+begin_src js -n
const API_PORT = process.env.API_PORT;
#+end_src

#+name:app-listen-api-port
#+begin_src js +n
app.listen(API_PORT, () => console.log(`API Server is running on port ${API_PORT}`))
#+end_src

#+begin_src sh :tangle egghead-jwt-auth/Makefile
.phony : lesson6
lesson6 : FORCE
	(export API_PORT=5000;node lesson6;)
#+end_src

**** Test the Server
01:00 To test our API, we will use Postman.  If we go to ~localhost:5000~,
we're getting a =404=, =page not found=, because that route was not defined.  If we
try ~localhost:5000/resource~, we should see our public resource there.  If we try
~localhost:5000/resource/secret~, we can also see the content of this resource.

**** Block the Secret Resource Route
#+CINDEX:@code{express-jwt}
#+CINDEX:block protected routes
#+CINDEX:middleware
Our next step will be to block those requests by requesting a valid JSON web
token.  To do so, we will require the ~expressjwt~ middleware.

#+begin_src js :noweb yes
<<require-expressjwt>>
#+end_src

01:39 Let's now open a terminal, and install it, using ~yarn~[fn::this was done
in the prior lesson] [[add-express-jwt][express-jwt]].

#+CINDEX:@code{express-jwt} initialization
Good.  Now, let's define this middleware.  We can initialize this middleware by
using ~expressjwt~ and passing it some options.  If you are using a real
authentication server, you'd want to check for the =issuer=, the =audience=,
and more to validate the integrity of the server.

02:01 In our case, we will only check to see if the signature matches the one
from our authentication server, "mysupersecretkey", in this case.

#+begin_src js -n :noweb yes
<<jwtCheck>>
#+end_src

Finally, we can secure our private route by adding the middleware as the second
argument of our =app.get= method.

#+begin_src js -n :noweb yes
<<private-resource-route>>
#+end_src

**** Testing the Server with a Protected Route
We are now ready to restart our server and test it in Postman.

02:24 Now, if we try a protected route again, we see that we're getting an
error message, saying that no authorization token was found.

[[file:./resources/postman-unauthorized-get-40.png]]

Let's go to the Authorization section, and select a =Bearer Token= type of
authentication.

[[file:./resources/bearer-token-authentication-type-50.png]]

02:38 We can take a valid token from ~jwt.io~ in this case[fn::After first
entering the secret key "mysupersecretkey" in the =verify signature= box
[[file:./resources/jwt.io-secret-key-25.png]]], and simply paste that in the token
box in Postman.
: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6Ikp\
: vaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.oGFhqfFFDi9sJMJ1U2dWJZNYEiUQBEtZRVuwKE7Uiak

We can now try to make our call to =/resource/secret= again, and we can now see
the content of this route.  Now, you have an API with a secured endpoint.

[[file:./resources/postman-with-bearer-token-40.png]]

**** Lesson 6 ~index.js~ Code

#+caption:Lesson 6 ~index.js~ Code
#+name:Lesson6-index.js
#+begin_src js :tangle egghead-jwt-auth/lesson6/index.js :noweb yes :mkdirp yes
<<require-express>>
<<require-body-parser>>
<<require-cors>>
<<require-expressjwt>>
<<jwtCheck>>

<<app-express>>
<<app-use-cors>>
<<app-use-body-parser>>

<<public-resource-route>>
<<private-resource-route>>
<<catchall-route>>

<<api-port>>
<<app-listen-api-port>>
#+end_src

*** Lesson 7---Connect a Front-End to a Secure API using JWTs
In this lesson, we add the login form to a single page application and we pass
our tokens to the API.  Should the token be valid, we will have access to the
data from the secure endpoint in the API.

**** The Single Page Application
#+name:index.html
#+begin_src html -n :tangle egghead-jwt-auth/lesson7/index.html :mkdirp yes
<html>
<head>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
</head>

<body>
<div class="container container-fluid">
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <a class="navbar-brand" href="#">Secure your SPA</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
                <li class="nav-item active" data-route="#">
                    <a class="nav-link" href="#">Home</a>
                </li>
            </ul>
            <form class="form-inline">
                <button class="btn btn-outline-success my-2 my-sm-0" data-toggle="modal" data-target="#loginModal" type="button" id="loginModalBtn">Login</button>&nbsp;
                <button class="btn btn-outline-danger d-none" id="logoutBtn">Logout</button>
            </form>
        </div>
    </nav>

    <span id="mainPage">

        <div class="row">
            <div class="col-1"></div>
            <div class="col-10 text-center">
                <p>Welcome to the headline generator application.  Click on the buttons to get a headline</p>
            </div>
            <div class="col-1"></div>
        </div>

        <div class="row">
            <div class="col-12 text-center">
                <button class="btn btn-lg btn-primary" id="headline">Public</button>&nbsp;
                <button class="btn btn-lg btn-secondary" id="secret">Private</button>
            </div>
        </div>

        <div class="row">&nbsp;</div>

        <div class="row">
            <div class="col-2"></div>
            <div class="col-8">
                <div class="alert alert-dark" style="overflow-wrap: break-word">
                    Test the API
                </div>
            </div>
            <div class="col-2"></div>
        </div>

        <div class="row justify-content-center">
            <div class="col-4 text-center">
                <img src="http://http.cat/200" id="httpcat" width="350px"/>
            </div>
        </div>
    </span>

    <span id="secretPage" class="d-none">
        This is a secret area!
    </span>

    <span id="unauthorizedPage" class="d-none">
        You are not authorized to see this page.
    </span>
</div>

<div class="modal fade" id="loginModal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="loginModalLabel">Modal title</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <form>
                    <div class="form-group">
                        <label for="username">Username</label>
                        <input type="text" class="form-control" id="username">
                    </div>
                    <div class="form-group">
                        <label for="password">Password</label>
                        <input type="password" class="form-control" id="password">
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
                <button type="button" class="btn btn-primary" data-dismiss="modal" id="loginBtn">Login</button>
            </div>
        </div>
    </div>
</div>


<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

<script src="./ui-update.js"></script>
<script src="./index.js"></script>
</body>
</html>
#+end_src

**** The Helper Functions in UI-Update
#+name:ui-update.js
#+begin_src js -n :tangle egghead-jwt-auth/lesson7/ui-update.js :mkdirp yes
let UIUpdate = {};

UIUpdate.loggedIn = function(token) {
  UIUpdate.alertBox(`Just logged in<br>Token:<br>${localStorage.getItem("access_token")}`);
  loginModalBtn.classList.add("d-none");
  logoutBtn.classList.remove("d-none");
};

UIUpdate.loggedOut = function() {
  localStorage.removeItem("access_token");
  loginModalBtn.classList.remove("d-none");
  logoutBtn.classList.add("d-none");
};

UIUpdate.routeChange = function() {
  if (document.querySelector(".navbar-nav li.active")) {
    document.querySelector(".navbar-nav li.active").classList.remove("active");
  }
  document.querySelector(".navbar [data-route='#" + window.location.hash.replace("#", "") + "']").classList.add("active");
};

UIUpdate.updateCat = function(status) {
  const httpCat = document.querySelector("#httpcat");
  httpCat.src = "http://http.cat/" + status;
};

UIUpdate.alertBox = function(message) {
  const alertBox = document.querySelector(".alert");
  alertBox.innerHTML = message;
};

UIUpdate.getUsernamePassword = function() {
  return {
    username: document.querySelector("#username").value,
    password: document.querySelector("#password").value
  }
};

window.addEventListener("hashchange", UIUpdate.routeChange);
#+end_src

**** The Authentication Server
#+name:auth.js
#+begin_src js -n :tangle egghead-jwt-auth/lesson7/auth.js :mkdirp yes :noweb yes
<<require-express>>
<<require-body-parser>>
<<require-jsonwebtoken>>
<<require-cors>>
<<users-array>>

<<app-express>>
<<app-use-body-parser>>
<<app-use-cors>>

<<authentication-login>>
<<create-access-token>>
<<catchall-route>>

<<port-env-or-assign>>
<<app-listen>>
#+end_src

**** The API Server
#+name:api.js
#+begin_src js -n :tangle egghead-jwt-auth/lesson7/api.js :mkdirp yes :noweb yes
<<require-express>>
<<require-body-parser>>
<<require-cors>>
<<require-expressjwt>>
<<jwtCheck>>

<<app-express>>
<<app-use-body-parser>>
<<app-use-cors>>

<<public-resource-route>>
<<private-resource-route>>
<<catchall-route>>

<<api-port>>
<<app-listen-api-port>>
#+end_src

**** Install Static Server ~httpster~
To set up a static file server for the front end, install ~httpster~ from NPM.
To start the server using =PORT 5000=, use
: yarn run httpster -p 5000 -d lesson7
from inside the root directory (~egghead-jwt-auth/~).

To start all of the servers (~auth~, ~api~, and ~frontend~), run the ~make~
command ~make lesson7~.  To terminate all of the servers, run the ~make~
command ~make kill~.  The ~auth~ server will run on =PORT 3000= while the ~api~
server will run on =PORT 3333=.

#+begin_src sh :results output :exports both :dir egghead-jwt-auth
yarn add httpster --dev
#+end_src

: package.json
: ------------
#+begin_src sh :results output :exports both :dir egghead-jwt-auth
cat package.json
#+end_src

#+begin_src sh :tangle egghead-jwt-auth/Makefile
.phony : lesson7
lesson7 : FORCE
	yarn run httpster -d lesson7 -p 5000 &
	export PORT=3000;node lesson7/auth.js &
	export API_PORT=3333;node lesson7/api.js &

.phony : kill
kill :
	pkill node
#+end_src

**** Framework of the Front End Connection
#+name:index.js
#+begin_src js -n :noweb tangle :tangle egghead-jwt-auth/lesson7/index.js
/* To run this file on a server, we are using httpster.
Type `httpster index.html -p 5000` in your console to start the server. */

<<api-url>>
<<auth-url>>

<<access-token>>

const headlineBtn = document.querySelector("#headline");
const secretBtn = document.querySelector("#secret");
const loginBtn = document.querySelector("#loginBtn");
const logoutBtn = document.querySelector("#logoutBtn");

<<headlineBtn.addEventListener>>

<<secretBtn.addEventListener>>

<<loginBtn.addEventListener>>

<<logoutBtn.addEventListener>>

#+end_src
**** Connect the Front End to the API Server
#+CINDEX:api server
00:00 To connect our front-end to our API in our authentication server, we
first need the URL for those.  In this case, I started the API on port 8888, so
we can add that to a constant.

#+name:api-url
#+begin_src js
const API_URL = "http://localhost:3333";
#+end_src

#+CINDEX:authentication server
00:18 The authentication server is also running at =http://localhost:3000=.
Let's add this to the =AUTH_URL= constant.

#+name:auth-url
#+begin_src js
const AUTH_URL = "http://localhost:3000";
#+end_src

#+CINDEX:@code{ACCESS_TOKEN}
We will keep the =ACCESS_TOKEN= from our authentication server stored in
memory.  For now, we can initialize the =ACCESS_TOKEN= constant to =undefined=.

#+name:access-token
#+begin_src js
let ACCESS_TOKEN = undefined;
#+end_src

**** Look at the Prebuilt Front End
#+CINDEX:front end
#+CINDEX:jumbotron
#+CINDEX:AJAX calls
00:36 Let's take a look at the front-end that was pre-built for us.  There is a
button labeled =public=, and another labeled =private=.  They will both update
the jumbotron beneath it with the response that we're getting from our AJAX
calls.

[[file:./resources/prebuilt-frontend-25.png]]

#+CINDEX:helper functions
#+CINDEX:@code{UI_Updates}
00:50 The image of the cat will also be updated with the status code that we
are getting from the server.  For the =UIUpdate= functions, all of the helper
functions are already created.  We will focus on the actual logic in here.

**** Set Up Buttons in Front End

{{{heading(The PUBLIC Button)}}}

#+CINDEX:public button
01:03 For now, none of the buttons do anything.  Let's go back to our code in
~index.js~.

#+CINDEX:@code{/resource} endpoint
#+CINDEX:API server
The variable =headlineBtn= holds a reference to the button labeled =public=.
We will start by doing a ~fetch~ to our public ~/resource~, which is on the API
server at the ~/resource~ endpoint.

#+CINDEX:@code{fetch}
#+CINDEX:promise, from @code{fetch} call
01:23 ~fetch~ returns a promise, so we will use the ~then~ method with the
response and we will return the result of =resp.text=.  This will return the
actual data in text format to the next chained ~.then~ method.

#+CINDEX:jumbotron
#+CINDEX:@code{UI_Update} object
01:40 Finally, we can use the =UIUpdate= object and the ~alertBox~ method to update
the jumbotron with the data from our response.

#+name:headlineBtn.addEventListener
#+begin_src js -n
  headlineBtn.addEventListener("click", () => {
          fetch(`${API_URL}/resource`).then(resp => {
              UIUpdate.updateCat(resp.status);
              return resp.text();
          }).then(data => {
              UIUpdate.alertBox(data);
          });
  });
#+end_src

{{{subheading(Test the PUBLIC Button)}}}

01:51 We are ready to test our first AJAX call.  Clicking on the =public=
button shows the public resource.  You can see this message.  That works.

{{{heading(The PRIVATE Button)}}}

#+CINDEX:private button
02:00 Let's now move on to the second button, the one labeled =private=.  In
here, we will do a very similar code.  We start by doing a ~fetch~ to the
=API_URL= and ~/resource/secret~ URL.  We return the ~.text~ from the response
and we update our jumbotron the same way we did for the public button.

#+begin_src js -n
  secretBtn.addEventListener("click", (event) => {
          fetch(`${API_URL}/resource/secret`).then(resp => {
              UIUpdate.updateCat(resp.status);
              return resp.text();
          }).then(data => {
              UIUpdate.alertBox(data);
          });
  });
#+end_src

{{{subheading(Test the PRIVATE Button)}}}

#+CINDEX:authorization header
02:25 If we go and test this, we will see that we are getting an error message
instead of the actual response that we are expecting.  That is due to the fact
that we have not passed in an authorization header.

#+CINDEX:@code{UIUpdate.updateCat} method
#+CINDEX:@code{resp.status} code
02:35 Now that we know that this URL will sometimes return us an error code,
let's update our =httpCat= with the response that we get from the server.
Before we return the parse body of our response, we can use the
=UIUpdate.updateCat= method with the =resp.status= code.

#+begin_src js
  secretBtn.addEventListener("click", (event) => {
          fetch(`${API_URL}/resource/secret`).then(resp => {
              UIUpdate.updateCat(resp.status);
              return resp.text();
          }).then(data => {
              UIUpdate.alertBox(data);
          });
  });
#+end_src

#+CINDEX:401 error code
#+CINDEX:unauthorized access
02:52 If we try this again, we see that we're getting a =401=, which is the error
code for an =unauthorized access=.

**** Authentication
#+CINDEX:authenticate
#+CINDEX:login
#+CINDEX:@code{LOGIN} button
#+CINDEX:authorization server
03:00 Before we can pass in a token with our request, we will need to
authenticate.  Let's go to the =login= button click event listener and do a
=POST= request to our authorization server.

#+CINDEX:Content-Type
#+CINDEX:application/json
#+CINDEX:request headers
#+CINDEX:headers, request
#+CINDEX:accept header
03:12 In here, we will do a request to the =${AUTH_URL}/login= endpoint.  We
will also specify a few options with our request.  First, this is not a =GET=,
so we will need to add method =POST=; then we need to specify the headers to
tell our server that we are sending =Content-Type:"application/json"=.

#+CINDEX:@code{UIUpdate} helper object
03:31 We need to specify that we are ~accepting~ a response type of
"application/json".  The body of our request will be the =username= and
=password= in JSON format provided by our =UIUpdate= helper object.

#+CINDEX:@code{httpCat}
03:47 We will update our =httpCat= with the ~resp.status~ code.  If we get a
=200=, we will send the JSON object from our response to the next promise.  If
our response was anything else, we will use the text of the response.

#+CINDEX:@code{ACCESS_TOKEN}
04:01 We can then chain with another ~.then~ and verify the presence of an
=ACCESS_TOKEN=.  If we have one, we can store the =ACCESS_TOKEN= in the
=ACCESS_TOKEN= variable that we defined in the beginning.

#+CINDEX:@code{UIUpdate.loggedIn} method
04:22 We can also overwrite the content of data with =ACCESS_TOKEN=: and the
content of the token.  If we have an =ACCESS_TOKEN=, this means that we are
logged in, so we can use the ~UIUpdate.loggedIn~ method to update our UI.

#+CINDEX:jumbotron
04:43 Finally, we will update our jumbotron with our data variable.

#+name:loginBtn.addEventListener
#+begin_src js -n
  loginBtn.addEventListener("click", (event) => {
      fetch(`${AUTH_URL}/login`, {
          method: "POST",
          headers: {
              "Content-Type": "application/json",
              "accept": "application/json",
          },
          body: JSON.stringify(UIUpdate.getUsernamePassword())
      }).then(resp => {
          UIUpdate.updateCat(resp.status);
          if (resp.status == 200) {
              return resp.json();
          } else {
              return resp.text();
          }
      }).then(data => {
          if (data.access_token) {
              ACCESS_TOKEN = data.access_token;
              data = `Access Token: ${data.access_token}`;
              UIUpdate.loggedIn();
          }
          UIUpdate.alertBox(data);
      });
  });
#+end_src

**** Test the Authentication Login
Let's try this out.

#+CINDEX:400 status
#+CINDEX:bad request, 400
04:54 If we click on =login=, we have a modal asking for our credentials.  If we
enter nothing, we are getting a =400= bad request error with the message, "You
need a username and password."

#+CINDEX:401 status
#+CINDEX:unauthorized error
05:05 Let's try to enter =username= "admin", and an invalid password.  This
time, we are getting a =401= =unauthorized= with the message, "User not found."

#+CINDEX:access token, receive
Now, if we use the right =username= and =password= combination, we are getting
an access token.

#+CINDEX:@url{jwt.io}
05:20 If we copy and paste the access token in ~jwt.io~, we can see the content
of the token.  It has the right username.

05:30 Back to our application, if we click on =private=, we are still getting a
"No authorization token was found" error message.  That's because we are still
not passing a token with our request.

**** Set Up Authentication to the Private Route
#+CINDEX:headers, request
#+CINDEX:@code{secretBtn}
05:43 Back to the =secretBtn=, let's start by defining our headers.  We can
start by initializing with an empty object, then we test to see if =ACCESS_TOKEN=
is still =undefined= or if we have an =ACCESS_TOKEN= stored there.

#+CINDEX:bearer token
05:58 If we do, we can specify the headers.  We will add an "Authorization" with
the value of =Bearer= followed by a space, and then =${ACCESS_TOKEN}=.

06:13 Now, we can add those through our request as a second argument to our
~fetch~.

#+name:secretBtn.addEventListener
#+begin_src js -n
secretBtn.addEventListener("click", (event) => {
	let headers = {};
	if (ACCESS_TOKEN) {
		headers = {
			"Authorization": `Bearer ${ACCESS_TOKEN}`
		};
	}
	fetch(`${API_URL}/resource/secret`, { headers }).then(resp => {
		UIUpdate.updateCat(resp.status);
		return resp.text();
	}).then(data => {
		UIUpdate.alertBox(data);
	});
});
#+end_src

**** Test Authentication to Private Resource Route
Let's test this out.  Start by refreshing the app, and then log in using =admin=
and the valid password.

#+CINDEX:secret resource
06:27 Now, if you click on =private=, you'll get the secret resource.  You should
be logged in to see this message.  We now have access to our secret resource.

**** Log Out Procedure
#+CINDEX:@code{logoutBtn}
#+CINDEX:@code{UIUpdate.loggedout} method
06:36 Finally, we will need a way to log out.  If we go to the =logoutBtn= "click"
event handler, we can simply reset our =ACCESS_TOKEN= to =undefined= and use the
~UIUpdate.loggedout~ method.

#+name:logoutBtn.addEventListener
#+begin_src js -n
logoutBtn.addEventListener("click", (event) => {
	ACCESS_TOKEN = undefined;
	UIUpdate.loggedOut();
});
#+end_src

06:51 One last time to our application, and we can now ~login~ using a valid
credential and get access to the =private= button.  Now, if you log out and try
the =private= button again, you're getting the =401= error with the "No
authorization token found" error message again.

07:09 That's it.  You now have a front-end that access both public and private
data from an API using a JSON web token.

* Listings
:PROPERTIES:
:unnumbered: t
:END:
#+texinfo:@listoffloats Listing

* Concept Index
:PROPERTIES:
:index:    cp
:unnumbered: t
:END:
* Export Settings                                                  :noexport:
** Options
#+options: H:4 ':t
** Texinfo Export Settings
#+texinfo_filename:security.info
#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+subauthor:
#+texinfo_dir_category:WebDev
#+texinfo_dir_title:Security
#+texinfo_dir_desc:Security information
#+texinfo_printed_title:Security Information
#+subtitle:For WebDev
** Macro Definitions
#+macro:heading @@texinfo:@heading $1@@
#+macro:subheading @@texinfo:@subheading $1@@
#+macro:dfn @@texinfo:@dfn{$1}@@
#+macro:noindent @@texinfo:@noindent @@
