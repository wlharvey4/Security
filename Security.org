# -*- mode:org; fill-column:79; -*-
#+title:Security Information
#+author:Pinecone062
#+date:April 14, 2019
#+macro:version 0.2.2.<2019-04-30 Tue 11:54>
Version {{{version}}} By {{{author}}}

* JSON Web Tokens
** Article---How JWTs Secure Your API
:PROPERTIES:
:source-url:   https://vuejsdevelopers.com/2019/04/15/api-security-jwt-json-web-tokens/?
:source-title: How JSON Web Token (JWT) Secures Your API
:source-author: Anthony Gore
:source-date: April 14, 2019
:END:
*** Introduction From How JWTs Securre Your API
You've probably heard that the JSON Web Token (JWT) is the current
state-of-the-art technology for securing APIs.  Like most security topics, it's
important to understand how it works (at least, somewhat) if you're planning to
use it.  The problem is that most explanations of JWT are technical and
headache-inducing.  Let's see if I can explain how a JWT can secure your API
without crossing your eyes!

*** API Authentication

@@texinfo:@heading Need to Authenticate Access@@

#+CINDEX:authentication
Certain API resources need restricted access.  We don't want one user to be
able to change the password of another user, for example.  That's why we
protect certain resources---make users supply their ID and password before
allowing access---in other words, we authenticate them.

@@texinfo:@heading HTTP Requests are Stateless@@

#+CINDEX:stateless, HTTP
The difficulty in securing an HTTP API is that requests are stateless---the API
has no way of knowing whether any two requests were from the same user or not.
So why don't we require users to provide their ID and password on every call to
the API?  Only because that would be a terrible user experience.

*** JSON Web Token
:PROPERTIES:
:article-title: What is a JSON Web Token?
:article-cite: https://robmclarty.com/blog/what-is-a-json-web-token
:article-author: Rob McLarty
:END:
What we need is a way to allow a user to supply their credentials just once,
but then be identified in another way by the server in subsequent requests.
Several systems have been designed for doing this, and the current
state-of-the-art standard is the JSON Web Token.

@@texinfo:@heading How JWTs Work@@

There's a great [[https://robmclarty.com/blog/what-is-a-json-web-token][article]] on the topic which makes a good analogy about how JSON
web tokens work:
#+begin_quote
Instead of an API, imagine you're checking into a hotel.  The "token" is the
plastic hotel security card that you get that allows you to access your room,
and the hotel facilities, but not anyone else's room.  When you check out of
the hotel, you give the card back.  This is analogous to logging out.
#+end_quote

*** Structure of the Token

@@texinfo:@heading What a JWT Looks Like@@

#+CINDEX:HTTP request header
#+CINDEX:header, HTTP request
#+CINDEX:request, HTTP header
#+CINDEX:bearer, authorization
#+CINDEX:authorization, bearer
#+CINDEX:token
#+CINDEX:bearer token
Normally a JSON web token is sent via the header of HTTP requests. Here's what
one looks like:
: Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dozjgNryP4J3jVmNHl0w5N_XgL0n3I9PlFUP0THsR8U
In fact, the token is the part after "Authorization: Bearer", which is just the
HTTP header info.

@@texinfo:@heading The Header Payload and Signature@@

#+CINDEX:header
#+CINDEX:payload
#+CINDEX:signature
#+CINDEX:Base 64 encode
Before you conclude that it's incomprehensible gibberish, there are a few
things you can easily notice.  Firstly, the token consists of three different
strings, separated by a period.  These three string are base 64
encoded[fn::Base 64 encoding is a way of transforming strings to ensure they
don't get screwed up during transport across the web.  It is not a kind of
encryption and anyone can easily decode it to see the original data.] and
correspond to:
- the /header/,
- the /payload/, and
- the /signature/.


We can decode these strings to get a better understand of the structure of JWT.

@@texinfo:@subheading Header@@

#+CINDEX:header, dfn
The following is the decoded header from the token.  The @@texinfo:@dfn{header}@@ is
meta information about the token.  It doesn't tell us much to help build our
basic understanding, so we won't get into any detail about it.

#+BEGIN_SRC js
{
  "alg": "HS256",
  "typ": "JWT"
}
#+END_SRC

@@texinfo:@subheading Payload@@

#+CINDEX:payload, dfn
The payload is of much more interest.  The @@texinfo:@dfn{payload}@@ can include any
data you like, but you might just include a user ID if the purpose of your
token is API access authentication.

#+BEGIN_SRC js
{
  "userId": "1234567890"
}
#+END_SRC

It's important to note that the payload is not secure.  Anyone can decode the
token and see exactly what's in the payload.  For that reason, we usually
include an ID rather than sensitive identifying information like the user's
email.  Even though this payload is all that's needed to identify a user on an
API, it doesn't provide a means of authentication.  Someone could easily find
your user ID and forge a token if that's all that was included.

So this brings us to the signature, which is the key piece for authenticating
the token.

*** Hashing Algorithms
#+CINDEX:hashing algorithm, dfn
#+CINDEX:hashing algorithm, SHA256
#+CINDEX:hash, dfn
#+CINDEX:SHA256 hashing algorithm
Before we explain how the signature works, we need to define what a
@@texinfo:@dfn{hashing algorithm}@@ is.  To begin with, it's a function for
transforming a string into a new string called a @@texinfo:@dfn{hash}@@.  For example,
say we wanted to hash the string "Hello, world".  Here's the output we'd get
using the =SHA256= hashing algorithm:
: 4ae7c3b6ac0beff671efa8cf57386151c06e58ca53a78d83f36107316cec125f
The most important property of the hash is that you can't use the hashing
algorithm to identify the original string by looking at the hash.  In other
words, we can't take the above hash and directly figure out that the original
string was "Hello, world". The hash is complicated enough that guessing the
original string would be infeasible.  There are many different types of hashing
algorithms, but =SHA256= is commonly used with JWT.

@@texinfo:@heading JWT Signature@@

#+CINDEX:signature, dfn
So coming back to the JWT structure, let's now look at the third piece of the
token, the @@texinfo:@dfn{signature}@@.  This actually needs to be calculated:

#+BEGIN_SRC js
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  "secret string"
);
#+END_SRC

Here's an explanation of what's going on here:

#+CINDEX:hashing function
- Firstly, =HMACSHA256= is the name of a hashing function and takes two
  arguments:
  - the string to hash, and
  - the "secret" (defined below).
- Secondly, the string we hash is the base 64 encoded /header/, plus the base 64
  encoded /payload/.
- Thirdly, the /secret/ is an arbitrary piece of data that only the server
  knows.


Why include the header and payload in the signature hash?  This ensures the
signature is unique to this particular token.

@@texinfo:@subheading The Secret@@

#+CINDEX:secret
What's the @@texinfo:@dfn{secret}@@?  To answer this, let's think about how you would
forge a token.  We said before that you can't determine a hash's input from
looking at the output.  However, since we know that the signature includes the
header and payload, as those are public information, if you know the hashing
algorithm (hint: it's usually specified in the header), you could generate the
same hash.  But the secret, which only the server knows, is not public
information.  Including it in the hash prevents someone generating their own
hash to forge the token.  And since the hash obscures the information used to
create it, no one can figure out the secret from the hash, either.

@@texinfo:@subheading Salting@@

#+CINDEX:salting
The process of adding private data to a hash is called @@texinfo:@dfn{salting}@@ and
makes cracking the token almost impossible.

*** Authentication Process
#+CINDEX:authentication process
So now you have a good idea of how a token is created.  How do you use it to
authenticate your API?

@@texinfo:@heading Login@@

#+CINDEX:token, generate
#+CINDEX:generate token
A token is generated when a user logs in and is stored in the database with the
user model.  The token then gets attached as the /authorization header/ in the
response to the login request.

#+caption:Generating a Token Upon Login; ~loginController.js~
#+name:generate-token
#+BEGIN_SRC js
if (passwordCorrect) {
  user.token = generateToken(user.id);
  user.save();
  res.headers("authorization", `Bearer ${token}`).send();
}
#+END_SRC

@@texinfo:@heading Authenticating requests@@

#+CINDEX:requests, authenticate
#+CINDEX:authenticate requests
Now that the client has the token, it can attach it to any future requests to
authenticate the identity of the user.  When the server receives a request with
an authorization token attached, the following happens:

1. It decodes the token and extracts the ID from the payload.
2. It looks up the user in the database with this ID.
3. It compares the request token with the one that's stored with the user's
   model.  If they match, the user is authenticated.

#+caption:The Server authenticates requests from the Client; ~authMiddleware.js~
#+name:authenticate-requests
#+BEGIN_SRC js
const token = req.header.token;
const payload = decodeToken(token);
const user = User.findById(payload.id);
if (user.token = token) {
  // Authorized
} else {
  // Unauthorized
}
#+END_SRC

@@texinfo:@heading Logging out@@

#+CINDEX:logout
If the user logs out, simply delete the token attached to the user model, and
now the token will no longer work.  A user will need to log in again to generate
a new token.

#+caption:Logging a user out; ~logoutController.js~
#+name:logout
#+BEGIN_SRC js
user.token = null;
user.save();
#+END_SRC

*** Wrapup
So that's a very basic explanation of how you can secure an API using JSON Web
Tokens.  I hope your head doesn't hurt too much.
** Course---JSON Web Token Authentication with Node.js
:PROPERTIES:
:source:   Egghead.io
:author:   Joel Lord
:END:
*** About the Course
In this course, we will build a simple authentication server that will act as a
token issuer, and we will use those tokens to access resources on an API.
Starting from scratch, the participants will learn how easy token based
authentication can be and will understand how to use them on their APIs as well
as on the front end of their web applications.
**** Source Code
[[https://github.com/eggheadio-projects/egghead-auth-course/tree/master][eggheadio-projects/egghead-auth-course]]
**** About the Author
- Joel Lord
- [[http://www.javascripteverything.com/about][About the author]]
- [[http://www.javascripteverything.com/about][Javascript Everything]] author's blog
- [[https://github.com/joellord][GitHub]]
**** Author's Introduction
00:00 Hey everyone, welcome to this course on JSON web token authentication
with Node.JS.  The goal of this course is to introduce you to web-based
authentication using JWTs.

00:11 Through these few lessons, we will build a simple application that will
connect to a secured API and we will build an authentication server to provide
us with tokens that we need in order to connect and access those routes.

00:25 We will start slowly by building a simple web server using Express.  We
will then see how to make this API more flexible by introducing environment
variables, and then how to handle post request, and how to parse the body of
those requests.

00:40 At this point, we will be able to start building our authentication
server.  The server will validate the user credentials and provide those users
with a JSON web token.  Using this token, we will be able to go back to our API
and secure one of our routes so that only an authenticated user can access
those resources.

00:59 Finally, what would a back-end be without a good UI? We will build a
quick front-end that will connect to our API.  This UI will also collect user
credentials and send them over to the authentication server to fetch a JWT.

01:13 All this will be done using plain old vanilla JavaScript and none of
those fancy frameworks.  This will give you all the necessary tools to
implement this solution in any application you might build.

01:25 Of course, the examples in this course will be simple, and we will focus
more on the concepts rather than building a real secure API.  For that reason,
we will also show you how to switch your primitive authentication server to use
a proven solution.

01:40 In this lesson, you will be introduced to Auth0 as a solution to provide
secure identity management and federated log in to your users.  Go ahead, watch
this course, and learn how to build more secure applications right now.
**** Directory and Package Setup
The course will be set up in a root directory ~egghead-jwt-auth~, with
~lesson#~ directories for each lesson 1 through 8.  The following two code
blocks create the root directory and then initializes a Node package within it.

#+NAME:tangle-files
#+BEGIN_SRC emacs-lisp :results silent :exports results
(org-babel-tangle-file (buffer-file-name))
#+END_SRC

#+name:package-init
#+begin_src sh :dir egghead-jwt-auth :results output :exports both
[ -e package.json ] && \
  echo "package.json has already been created" || \
  yarn --yes init
#+end_src

*** Lesson 1---Set Up a Web Server in Node.js Using Express
#+CINDEX:Express web server
#+CINDEX:web server, Express
#+CINDEX:server, Express web
#+CINDEX:404 error
In this lesson, we build a very simple Express server.  This server will have a
single route that displays the current date and time and a handler for =404=
pages.

**** Setting Up A Little Express Server
#+CINDEX:Express server, build
00:00 To build your first Express server, the first thing you need to do is to
~require express~.  In order for your code to be able to use it, you need to
install it using ~yarn add express:

#+name:lesson1-package.json
#+begin_src sh :dir egghead-jwt-auth :results output :exports both
yarn add express
#+end_src

#+name:lesson01-requires
#+begin_src js
const express = require('express');
#+end_src

@@texinfo:@heading Setup Constants@@

#+CINDEX:PORT, define
00:16 We'll go back to our code.  We'll declare a new constant ~app~ which will
use the ~express~ library that we've just included.  We'll also declare a new
constant for the =PORT= number.  We'll use =8888= for now.

#+name:lesson01-setup
#+begin_src js
const app = express();
const PORT = 8888;
#+end_src

{{{heading(Setup Routes)}}}

{{{subheading(Status Route)}}}

#+CINDEX:route, define
#+CINDEX:@code{app.get}
#+CINDEX:status route
00:30 Then we can do our first route.  We'll use ~app.get~, and we'll specify
the name of the route.  In this case, we're using =status=, and it takes a
callback which has a request and a response as parameters.

#+name:lesson01-routes
#+begin_src js
app.get('/status', (req, res) => {
    const localTime = (new Date()).toLocaleTimeString();
    res.status(200).send(`Server time is ${localTime}.`);
});
#+end_src

@@texinfo:@subheading Catchall Route@@

#+CINDEX:catchall route
01:13 Let's also add a catchall route. We'll just use star (=*=), which means
any route that wasn't defined already.  01:19 It also takes a callback with a
request and response.  We can build our response here, and it will simply sense
that as =404=, or 'page not found'.

#+name:lesson01-routes
#+begin_src js
app.get('*', (req, res) => {
    res.sendStatus(404);
});
#+end_src

{{{heading(Start the App Listening)}}}

#+CINDEX:@code{app.listen}
#+CINDEX:app, run
01:30 Finally, we'll use ~app.listen~ to initialize our server.  It'll take a
=PORT=---which we've defined earlier---as a parameter, and a callback for on
success.  01:42 We'll simply say "Server is running on port", and we'll specify
the =PORT= number here.  You now have your first express server.

#+name:lesson01-listen
#+begin_src js
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}.`);
});
#+end_src

**** Testing the Server

This Makefile sets up some commands to run specific lessons.  This first rule
links Lesson1 ~index.js~ into the root directory, then starts the server.

#+BEGIN_SRC sh :tangle egghead-jwt-auth/Makefile
FORCE:

.phony : lesson1
lesson1 : FORCE
	ln -f lesson1/index.js index.js
	node .

#+END_SRC

01:53 If we go back to our terminal, we can start the server by using Node from
the root directory:
: make lesson1

We've got our server running.

These three Makefile rules provide easy commands to open different routes in
your default browser:

#+BEGIN_SRC sh :tangle egghead-jwt-auth/Makefile
.phony: open-browser
open-browser :
	open http://localhost:8888/

.phony: open-browser-status
open-browser-status :
	open http://localhost:8888/status/

.phone: open-browser-random
open-browser-random :
	open http://localhost:8888/random/

#+END_SRC

#+CINDEX:page not found error
02:02 Now if we go through our browser window, we can type in the
~localhost:8888~.  We'll get a 'page not found' because that route was not
defined.
: make open-browser

#+CINDEX:status route
02:10 We can use =/status= to get the server time, and any other page will give
us a =404= error.
: make open-browser-status
: make open-browser-random

That's it.  You've got your first Express server up and running.
**** Express Server Index.js Code
#+caption:Lesson 1 Index.js
#+name:lesson01-index.js
#+begin_src js :tangle egghead-jwt-auth/lesson1/index.js :mkdirp yes :noweb yes
<<lesson01-requires>>

<<lesson01-setup>>

<<lesson01-routes>>

<<lesson01-listen>>
#+end_src

* Listings
:PROPERTIES:
:unnumbered: t
:END:
#+texinfo:@listoffloats Listing

* Concept Index
:PROPERTIES:
:index:    cp
:unnumbered: t
:END:
* Export Settings                                                  :noexport:
** Options
#+options: H:4
** Texinfo Export Settings
#+texinfo_filename:security.info
#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+subauthor:
#+texinfo_dir_category:WebDev
#+texinfo_dir_title:Security
#+texinfo_dir_desc:Security information
#+texinfo_printed_title:Security Information
#+subtitle:For WebDev
** Macro Definitions
#+macro:heading @@texinfo:@heading $1@@
#+macro:subheading @@texinfo:@subheading $1@@
#+macro:dfn @@texinfo:@dfn{$1}@@
